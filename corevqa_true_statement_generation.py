# -*- coding: utf-8 -*-
"""COREVQA True Statement Generation

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15r2umyM2bldKTxjrDIR_Q11Yh5waGVNR
"""

!pip install openai pillow pandas tqdm huggingface_hub

import os, time, json, zipfile, base64, csv
import pandas as pd
from tqdm import tqdm
from PIL import Image
from huggingface_hub import hf_hub_download
import openai

from google.colab import userdata

openai.api_key = "YOUR_API_KEY_HERE"

general_wrap_validator_functionclient = openai.Client(api_key=openai.api_key)

gpt_client = openai.Client(api_key=openai.api_key)

true_prompt ='''**Tricky Yet True Image Statement Generator**
You are an expert vision-language assistant tasked with creating statements about images that are factually correct but deliberately crafted to be challenging to verify. These statements will be used for a visual question answering dataset designed to test the limits of perception and reasoning.
**Instructions**
Analyze the provided image and create a **single, complex true statement** that is difficult to verify at first glance but remains objectively true upon careful inspection. Your statement should:
1. Use challenging linguistic constructions:
   * Negations (what is NOT present or NOT happening)
   * Complex comparatives
   * Logical relationships
   * Precisely worded quantifiers
   * Statements about relationships between multiple elements
2. Incorporate visually verifiable but easily missed details about people:
   * Hand positions or gestures (crossed arms, pointing, holding objects)
   * Gaze direction and who/what they are looking at
   * Partial visibility (person partially out of frame or occluded)
   * Subtle clothing details (patterns, logos, layers, accessories)
   * Positional anomalies (the only person sitting/standing/facing away)
**Advanced Requirements**
* Your statement MUST be 100% verifiable as true from the image alone
* Craft statements that require multiple visual checks to confirm
* Include at least 2 distinct observations that make the statement complex
* Favor statements that a casual viewer might initially doubt but can verify upon closer inspection
* Utilize precision language that leaves no room for ambiguity
* Length should be approximately 20-30 words - detailed enough to be tricky
**Output Format**
**STATEMENT:** [Your tricky but true statement about the image]
**REASONING:** [A list of specific visual evidence as proof]'''

CSV_PATH = hf_hub_download(repo_id="COREVQA2025/COREVQA", filename="COREVQA.csv", repo_type="dataset")

def download_and_unzip(filename, target_dir):
    path = hf_hub_download(repo_id="COREVQA2025/COREVQA", filename=filename, repo_type="dataset")
    os.makedirs(target_dir, exist_ok=True)
    with zipfile.ZipFile(path, 'r') as zip_ref:
        zip_ref.extractall(target_dir)

download_and_unzip("CrowdHuman_train01.zip", "/content/crowdhuman_train01")
download_and_unzip("CrowdHuman_train02.zip", "/content/crowdhuman_train02")

image_folder_paths = {
    "train01": "/content/crowdhuman_train01/Images",
    "train02": "/content/crowdhuman_train02/Images",
}

PROCESSED_JSON_PATH = "/content/processed_images.json"
FINAL_CSV_PATH = "/content/COREVQA_GENERATED.csv"
BATCH_SIZE = 25
MODE = "TRUE"  # or "FALSE"

def encode_image(path):
    with open(path,"rb") as f:
        return base64.b64encode(f.read()).decode("utf-8")

def get_image_path(image_id):
    folder, fn = image_id.split('/')
    return os.path.join(image_folder_paths[folder], fn)

def load_json(path):
    if os.path.exists(path):
        return json.load(open(path,"r"))
    return []

def save_json(data,path):
    json.dump(data, open(path,"w"))

def generate_question(image_id):
    prompt = true_prompt
    img_b64 = encode_image(get_image_path(image_id))
    resp = client.chat.completions.create(
        model=model_name,
        messages=[{"role":"user","content":[
            {"type":"text","text":prompt},
            {"type":"image_url","image_url":{"url":f"data:image/jpeg;base64,{img_b64}"}}
        ]}],
        temperature=0.7,
        max_tokens=80
    )
    text = resp.choices[0].message.content
    if "**STATEMENT:**" in text:
        return text.split("**STATEMENT:**")[1].split("**REASONING:**")[0].strip()
    return text.strip()

df = pd.read_csv(CSV_PATH, encoding="utf-8-sig")
df.columns = [c.strip().lower() for c in df.columns]
entries = df[df["answer"].str.lower().isin(["true","false"])]
image_ids = [img for img in entries["image_id"] if os.path.exists(get_image_path(img))]
processed = load_json(PROCESSED_JSON_PATH)
to_process = [i for i in image_ids if i not in processed]

for start in range(0, len(to_process), BATCH_SIZE):
    batch = to_process[start:start+BATCH_SIZE]
    for img_id in tqdm(batch, desc=f"Batch {start//BATCH_SIZE+1}"):
        try:
            stmt = generate_question(img_id)
            df.loc[df["image_id"]==img_id, "question"] = stmt
            df.loc[df["image_id"]==img_id, "answer"] = MODE
            processed.append(img_id)
            save_json(processed, PROCESSED_JSON_PATH)
            time.sleep(1)
        except:
            continue

df.to_csv(FINAL_CSV_PATH, index=False, quoting=csv.QUOTE_MINIMAL)

df.to_csv("/content/COREVQA_GENERATED.csv", index=False, quoting=csv.QUOTE_MINIMAL)
