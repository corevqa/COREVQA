# -*- coding: utf-8 -*-
"""COREVQA False Statement Generation

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VEBi12Ggt45jE3AnMXbnsTonxZEwdMm1
"""

!pip install anthropic pillow pandas tqdm huggingface_hub

import os, time, json, zipfile, base64, csv
import pandas as pd
from tqdm import tqdm
from PIL import Image
from huggingface_hub import hf_hub_download
import anthropic

from google.colab import userdata

CLAUDE_API_KEY = userdata.get("CLAUDE_API_KEY")
client = anthropic.Anthropic(api_key=CLAUDE_API_KEY)
model_name = "claude-3-opus-20240229"

false_prompt = '''You are writing a False statement about a given image. The statement should sound completely natural, confident, and plausible — but require close visual inspection to determine if it’s actually correct.
Your goal is to trick a model that relies on language, assumptions, or common sense — and force it to use detailed visual and contextual reasoning.
Do **not** invent things that are fully out of frame, completely occluded, or dependent on unreadable text. Avoid using color as the main trick — models are strong at detecting color.
All questions must:
- Be complex and require chain-of-thought to answer. The complexity should come from the lengthy and advanced thought process required to answer the image, NOT the detail of the statement itself.
**Important Strategy Choices.**:
:x: When writing a FALSE Statement:
Create a statement that seems plausible but is visually incorrect. The goal is to bait the model into trusting assumptions, not what’s actually in the image.
Implied Physical Stability — Suggest ambiguous leaning/support just based off proximity, not grounded in visual details.
Quantifier Bait — Use vague or tricky counts (e.g. “at least three,” “only one”) to confuse object detection.
Intention/Action Fallacy — Imply an impossible or contradictory action (e.g. someone trying to do something that seems right, but in context shows is not feasible).
Similar Object Confusion — Identify an object that resembles and is used in context of a similar object but is incorrectly labeled.
Occlusion Trap — Imply something is visible and confirmable, when it's actually hidden or blocked.
Causal Mislead — Imply a cause-effect relationship that isn't actually supported by the image context (e.g. “because X is happening, Y must be true”).
Back-to-Front Error — Describe an event in the background as if it’s in the foreground, causing false assumptions about prominence or relevance.
Non-Functional Object Claim — Attribute an incorrect purpose to an object (e.g. assuming a pipe is a handrail, or a bag is a tool).
Time-Based Confusion — Describe a sequence-dependent state that cannot be confirmed from a single frame (e.g. “this person has just finished climbing”).
Schema Reversal: Use roles that *sound expected* (e.g. “a coach giving a trophy”) but flip them visually (e.g. it’s actually a parent or official).
Implied Grouping: Suggest affiliation between people (e.g. teammates, family) based on position or dress — even if incorrect.
Hidden Contradictions: Embed one small, one or two word, subtle error (e.g. missing ID badge, wrong uniform, incorrect object) inside an otherwise believable sentence.
Overloaded Compositions: Combine multiple assumptions (e.g. action + role + object) so the model must validate *each part* to avoid error.
---
Before responding, analyze your initial response. Make sure it is visually grounded. Also ask, how can I trick someone? How can I trick them into thinking the WRONG answer?'''

CSV_PATH = hf_hub_download(repo_id="COREVQA2025/COREVQA", filename="COREVQA.csv", repo_type="dataset")

def download_and_unzip(filename, target_dir):
    path = hf_hub_download(repo_id="COREVQA2025/COREVQA", filename=filename, repo_type="dataset")
    os.makedirs(target_dir, exist_ok=True)
    with zipfile.ZipFile(path, 'r') as zip_ref:
        zip_ref.extractall(target_dir)

download_and_unzip("CrowdHuman_train01.zip", "/content/crowdhuman_train01")
download_and_unzip("CrowdHuman_train02.zip", "/content/crowdhuman_train02")

image_folder_paths = {
    "train01": "/content/crowdhuman_train01/Images",
    "train02": "/content/crowdhuman_train02/Images",
}

PROCESSED_JSON_PATH = "/content/processed_images.json"
FINAL_CSV_PATH = "/content/COREVQA_GENERATED.csv"
BATCH_SIZE = 25
MODE = "TRUE"  # or "FALSE"

def encode_image(path):
    with open(path,"rb") as f:
        return base64.b64encode(f.read()).decode("utf-8")

def get_image_path(image_id):
    folder, fn = image_id.split('/')
    return os.path.join(image_folder_paths[folder], fn)

def load_json(path):
    if os.path.exists(path):
        return json.load(open(path,"r"))
    return []

def save_json(data,path):
    json.dump(data, open(path,"w"))

def generate_question(image_id):
    prompt = false_prompt
    img_b64 = encode_image(get_image_path(image_id))
    resp = client.messages.create(
        model=model_name,
        messages=[{"role":"user","content":[
            {"type":"text","text":prompt},
            {"type":"image_url","image_url":{"url":f"data:image/jpeg;base64,{img_b64}"}}
        ]}],
        temperature=0.7,
        max_tokens=80
    )
    text = resp.choices[0].message.content
    if "**STATEMENT:**" in text:
        return text.split("**STATEMENT:**")[1].split("**REASONING:**")[0].strip()
    return text.strip()

df = pd.read_csv(CSV_PATH, encoding="ISO-8859-1")
df.columns = [c.strip().lower() for c in df.columns]
df = df.rename(columns={"human_label":"answer"})
entries = df[df["answer"].str.lower().isin(["true","false"])]
image_ids = [img for img in entries["image_id"] if os.path.exists(get_image_path(img))]
if "question" not in df.columns:
    df["question"] = ""
processed = load_json(PROCESSED_JSON_PATH)
to_process = [i for i in image_ids if i not in processed]

for start in range(0, len(to_process), BATCH_SIZE):
    batch = to_process[start:start+BATCH_SIZE]
    for img_id in tqdm(batch, desc=f"Batch {start//BATCH_SIZE+1}"):
        try:
            stmt = generate_question(img_id)
            df.loc[df["image_id"]==img_id, "question"] = stmt
            df.loc[df["image_id"]==img_id, "answer"] = MODE
            processed.append(img_id)
            save_json(processed, PROCESSED_JSON_PATH)
            time.sleep(1)
        except:
            continue

df.to_csv(FINAL_CSV_PATH, index=False, quoting=csv.QUOTE_MINIMAL)

df.to_csv("/content/COREVQA_GENERATED.csv", index=False, quoting=csv.QUOTE_MINIMAL)